/* -*- C++ -*- */

/*
   Copyright 2007 Deutsches Forschungszentrum fuer Kuenstliche Intelligenz 
   or its licensors, as applicable.
   
   You may not use this file except under the terms of the accompanying license.
   
   Licensed under the Apache License, Version 2.0 (the "License"); you
   may not use this file except in compliance with the License. You may
   obtain a copy of the License at http:  www.apache.org/licenses/LICENSE-2.0
   
   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
   
   Project: 
   File: 
   Purpose: 
   Responsible: kapry
   Reviewer: 
   Primary Repository: 
   Web Sites: www.iupr.org, www.dfki.de
*/

$#include "colib.h"
$#include "imgio.h"
$#include "imglib.h"

$using namespace colib;
$using namespace iulib;

module iulib {
// Image I/O

void read_image_packed(intarray &image, FILE *f,const char *fmt=0); 
void read_image_rgb(bytearray &image, FILE *f,const char *fmt=0); 
void read_image_gray(bytearray &image, FILE *f,const char *fmt=0); 
void read_image_binary(bytearray &image, FILE *f, const char *fmt=0); 
void read_image_packed(intarray &,const char *path);
void read_image_rgb(bytearray &, const char *path);
void read_image_gray(bytearray &, const char *path);
void read_image_binary(bytearray &, const char *path);
void write_image_packed(FILE *f,intarray &image, const char *fmt); 
void write_image_rgb(FILE *f,bytearray &image, const char *fmt); 
void write_image_gray(FILE *f,bytearray &image, const char *fmt); 
void write_image_binary(FILE *f,bytearray &image,const char *fmt);
void write_image_packed(const char *path,intarray &);
void write_image_rgb(const char *path, bytearray &);
void write_image_gray(const char *path,bytearray &);
void write_image_binary(const char *path,bytearray &);

void display(bytearray &image);
void display(intarray &image);
void make_page_black(bytearray &image);
void make_page_normalized_and_black(bytearray &image);
void make_page_binary_and_black(bytearray &image);
void make_page_binary_and_black(intarray &image);

// Image Processing Library

// imgops

void tighten(intarray &image);
void circ_by(intarray &image,int dx,int dy,int value=0);
void shift_by(intarray &image,int dx,int dy,int value=0);
void pad_by(intarray &image,int px,int py,int value=0);
void erase_boundary(intarray &image,int px,int py,int value=0);
void extract_subimage(intarray &subimage,intarray &image,int x0,int y0,int x1,int y1);
void resize_to(intarray &image,int w,int h,int value=0);

void addscaled(floatarray &,floatarray &,float,int,int);
void tighten(floatarray &image);
void circ_by(floatarray &image,int dx,int dy,float value=0);
void shift_by(floatarray &image,int dx,int dy,float value=0);
void pad_by(floatarray &image,int px,int py,float value=0);
void erase_boundary(floatarray &image,int px,int py,float value=0);
void extract_subimage(floatarray &subimage,floatarray &image,int x0,int y0,int x1,int y1);
void resize_to(floatarray &image,int w,int h,float value=0);

void addscaled(bytearray &,bytearray &,float,int,int);
void tighten(bytearray &image);
void circ_by(bytearray &image,int dx,int dy,unsigned char value=0);
void shift_by(bytearray &image,int dx,int dy,unsigned char value=0);
void pad_by(bytearray &image,int px,int py,unsigned char value=0);
void erase_boundary(bytearray &image,int px,int py,unsigned char value=0);
void extract_subimage(bytearray &subimage,bytearray &image,int x0,int y0,int x1,int y1);
void resize_to(bytearray &image,int w,int h,unsigned char value=0);
void compose_at(bytearray &image,bytearray &source,int x,int y,int value,int conflict);

void extract_subimage(intarray &subimage,intarray &image,int x0,int y0,int x1,int y1);

void linearly_transform_intensity(bytearray &,float,float,float,float);
void linearly_transform_intensity(intarray &,float,float,float,float);
void linearly_transform_intensity(floatarray &,float,float,float,float);
void gamma_transform(bytearray &,float,float,float,float);
void gamma_transform(intarray &,float,float,float,float);
void gamma_transform(floatarray &,float,float,float,float);
void expand_range(bytearray &,float,float);
void expand_range(intarray &,float,float);
void expand_range(floatarray &,float,float);

// imggauss

void gauss1d(floatarray &out,floatarray &in,float sigma);
void gauss1d(floatarray &v,float sigma);
void gauss2d(floatarray &a,float sx,float sy);
void gauss1d(bytearray &out,bytearray &in,float sigma);
void gauss1d(bytearray &v,float sigma);
void gauss2d(bytearray &a,float sx,float sy);

// imgedges

void rawedges(floatarray &edges,floatarray &smoothed);
float nonzero_fractile(floatarray &edges,float frac,int nbins=1000);
void hysteresis_thresholding(floatarray &image,float lo,float hi);
void gradients(floatarray &gradm,floatarray &gradx,floatarray &grady,floatarray &smoothed);
void canny(floatarray &gradm,floatarray &image,float sx,float sy, float frac=0.3,float tlow=2.0,float thigh=4.0);
void nonmaxsup(bytearray &out, floatarray &gradm, floatarray &gradx, floatarray &grady);

// imgthin

void thin(bytearray &);

// imgtrace

// FIXME this isn't working; write a test case, then fix it --tmb

struct IChainTracer {
    virtual void set_image(bytearray &image) = 0;
    virtual void clear() = 0;
    virtual bool get_chain(floatarray &points,bool close=false,int sample=1) = 0;
    virtual bool get_poly(floatarray &points,float maxdist=1.0,bool close=false) = 0;
    virtual ~IChainTracer();
};
IChainTracer *chaintracer(bytearray &image);

// imgbrushfire

void brushfire_2(floatarray &distance,float maxdist=1e30);
void brushfire_1(floatarray &distance,float maxdist=1e30);
void brushfire_inf(floatarray &distance,float maxdist=1e30);
void brushfire_2(floatarray &distance,narray<point> &source,float maxdist=1e30);
void brushfire_1(floatarray &distance,narray<point> &source,float maxdist=1e30);
void brushfire_inf(floatarray &distance,narray<point> &source,float maxdist=1e30);
void brushfire_2(floatarray &distance,intarray &source,float maxdist=1e30);
void brushfire_1(floatarray &distance,intarray &source,float maxdist=1e30);
void brushfire_inf(floatarray &distance,intarray &source,float maxdist=1e30);
void dilate_1(floatarray &image,float r);
void dilate_2(floatarray &image,float r);
void dilate_inf(floatarray &image,float r);
void erode_1(floatarray &image,float r);
void erode_2(floatarray &image,float r);
void erode_inf(floatarray &image,float r);
void brushfire_inf_scaled(floatarray &distance,float sx,float sy,float maxdist=1e38);
void brushfire_2_scaled(floatarray &distance,float a,float b,float c,float d,float maxdist=1e38);

// imglabels

void propagate_labels(intarray &image);
void propagate_labels_to(intarray &target,intarray &seed);
void remove_dontcares(intarray &image);
int renumber_labels(intarray &image,int start);
int label_components(intarray &image,bool four_connected=false);
void simple_recolor(intarray &image);
void bounding_boxes(rectarray &result,intarray &image);

// imgmap

void rotate_direct_sample(floatarray &out,floatarray &in,float angle,float cx,float cy);
void rotate_direct_interpolate(floatarray &out,floatarray &in,float angle,float cx,float cy);
void scale_sample(floatarray &out,floatarray &in,float sx,float sy);
void scale_sample(floatarray &out,floatarray &in,int nx, int ny);
void scale_interpolate(floatarray &out,floatarray &in,float sx,float sy);
void scale_interpolate(floatarray &out,floatarray &in,int nx, int ny);

void rotate_direct_sample(bytearray &out,bytearray &in,float angle,float cx,float cy);
void rotate_direct_interpolate(bytearray &out,bytearray &in,float angle,float cx,float cy);
void scale_sample(bytearray &out,bytearray &in,float sx,float sy);
void scale_sample(bytearray &out,bytearray &in,int nx, int ny);
void scale_interpolate(bytearray &out,bytearray &in,float sx,float sy);
void scale_interpolate(bytearray &out,bytearray &in,int nx, int ny);

// imgfilters

void horn_riley_ridges(floatarray &im,floatarray &zero,floatarray &strength,floatarray &angle);
void laplacian(floatarray &result,floatarray &image);
void zero_crossings(bytearray &result,floatarray &image);
void local_minima(bytearray &result,floatarray &image);
void local_maxima(bytearray &result,floatarray &image);
void gradient_based_corners(floatarray &image);
void kitchen_rosenfeld_corners(floatarray &corners,floatarray &image);
void kitchen_rosenfeld_corners2(floatarray &corners,floatarray &image);
void median_filter(bytearray &image, int rx, int ry);

// imgmorph

void make_binary(bytearray &image);
void binary_invert(bytearray &image);
void binary_autoinvert(bytearray &image);
void binary_and(bytearray &image,bytearray &image2,int dx=0,int dy=0);
void binary_or(bytearray &image,bytearray &image2,int dx=0,int dy=0);
void binary_erode_circle(bytearray &image,int r);
void binary_dilate_circle(bytearray &image,int r);
void binary_open_circle(bytearray &image,int r);
void binary_close_circle(bytearray &image,int r);
void binary_erode_rect(bytearray &image,int rw,int rh);
void binary_dilate_rect(bytearray &image,int rw,int rh);
void binary_open_rect(bytearray &image,int rw,int rh);
void binary_close_rect(bytearray &image,int rw,int rh);

// imggraymorph

void complement(bytearray &image);
void difference(bytearray &image,bytearray &image2,int dx=0,int dy=0);
int maxdifference(bytearray &image,bytearray &image2,int cx=0,int cy=0);
void gray_erode(bytearray &image,bytearray &mask,int cx,int cy);
void gray_dilate(bytearray &image,bytearray &mask,int cx,int cy);
void gray_open(bytearray &image,bytearray &mask,int cx,int cy);
void gray_close(bytearray &image,bytearray &mask,int cx,int cy);

// imgmisc

void valleys(intarray &locations,floatarray &v,int minsize=0,int maxsize=1<<30,float sigma=0.0);
void peaks(intarray &locations,floatarray &v,int minsize=0,int maxsize=1<<30,float sigma=0.0);
void math2raster(floatarray &,floatarray &);
void math2raster(intarray &,intarray &);
void math2raster(bytearray &,bytearray &);
void raster2math(floatarray &,floatarray &);
void raster2math(intarray &,intarray &);
void raster2math(bytearray &,bytearray &);

void iulib::hist @ hist(floatarray &hist,bytearray &image);

// utilities from colib

#ifdef TOLUA_109
$#include "env.h"

class param_string {
    param_string(const char *name,const char *dflt,const char *doc="");
    operator const char*();
};

class param_bool {
    param_bool(const char *name,bool dflt,const char *doc="");
    operator bool();
};

class param_int {
    param_int(const char *name,int dflt,const char *doc="");
    operator int();
};

class param_float {
    param_float(const char *name,float dflt,const char *doc="");
    operator float();
};

class param_double {
    param_double(const char *name,double dflt,const char *doc="");
    operator double();
};

#endif

} // module

